// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, MemoryStream, ReplrClient, ReplrEvents, ReplrServer, Util, async, chalk, cluster, extend, http, net, portscanner, terminal,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  net = require('net');

  http = require('http');

  extend = require('xtend');

  cluster = require('cluster');

  chalk = require('chalk');

  terminal = require('terminal');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  MemoryStream = require('memorystream');

  portscanner = require('portscanner');

  ReplrClient = require('./ReplrClient');

  ReplrEvents = require('./ReplrEvents');

  Util = require('./Util');

  ReplrServer = (function(_super) {
    __extends(ReplrServer, _super);

    ReplrServer.prototype.OPTIONS_DEFAULT = {
      name: 'Replr',
      port: 2323,
      mode: 'http',
      prompt: chalk.gray('replr> '),
      terminal: false,
      useColors: false,
      describeWorker: null
    };

    ReplrServer.prototype.OPTIONS_MODES = ['http', 'tcp', 'unixdomainsocket', 'raw', 'noserver'];

    ReplrServer.prototype.OPTIONS_REPL_KEYS = ['port', 'prompt', 'terminal', 'useColors', 'useGlobal', 'ignoreUndefined'];

    function ReplrServer(options, start) {
      if (start == null) {
        start = true;
      }
      options = options || {};
      if (options.port) {
        if (typeof options.port === 'number') {
          if (!Util.prototype.isInt(options.port) || options.port < 1) {
            throw new Error('bad port');
          }
        } else if (typeof options.port !== 'string') {
          throw new Error('bad port');
        }
      }
      if (options.prompt) {
        if (typeof options.prompt !== 'string') {
          throw new Error('bad prompt');
        }
      }
      if (options.mode) {
        if (this.OPTIONS_MODES.indexOf(options.mode) === -1) {
          throw new Error('bad mode');
        }
      }
      this.options = extend(this.OPTIONS_DEFAULT, options);
      this.clients = [];
      this.started = false;
      this.starting = false;
      if (start) {
        return this.start();
      } else {
        return this;
      }
    }

    ReplrServer.prototype.start = function(callback) {
      var onVerified, ready,
        _this = this;
      ready = function() {
        _this.started = true;
        _this.starting = false;
        return _this.emit('listening');
      };
      if (this.starting) {
        return;
      }
      this.starting = true;
      if (this.options.mode === 'noserver' || this.options.port === false) {
        return ready();
      }
      onVerified = function(err, status) {
        var mode, onError;
        if (err || status === 'open') {
          if (callback) {
            callback(err || new Error('Port already taken'));
          }
          return;
        }
        mode = _this.options.mode;
        if (mode === 'tcp' || mode === 'unixdomainsocket' || mode === 'raw') {
          _this.socketServer = net.createServer(_this.open.bind(_this));
        } else {
          _this.socketServer = http.createServer(function() {});
          _this.socketServer.on('upgrade', function(req, socket, head) {
            var exc, str;
            try {
              str = head.toString('utf8');
              if (req.headers && req.headers.upgrade === 'replr') {
                return _this.open(socket);
              } else {
                return socket.end();
              }
            } catch (_error) {
              exc = _error;
              return socket.end();
            }
          });
        }
        _this.socketServer.on('listening', function() {
          return ready();
        });
        onError = function(err) {
          if (callback) {
            return callback(err);
          }
        };
        _this.socketServer.once('error', onError);
        try {
          _this.socketServer.listen(_this.options.port);
        } catch (_error) {
          err = _error;
          _this.started = false;
          _this.starting = false;
          if (callback) {
            callback(err);
          }
        }
        return _this.socketServer.removeListener('error', onError);
      };
      if (this.options.port === 0) {
        return onVerified(null, 'free');
      } else if (typeof this.options.port === 'number') {
        return portscanner.checkPortStatus(this.options.port, '127.0.0.1', onVerified);
      } else {
        return onVerified(null, 'free');
      }
    };

    ReplrServer.prototype.close = function(callback) {
      var _this = this;
      if (this.starting) {
        return this.once('listening', function() {
          return _this.close(callback);
        });
      } else if (this.started) {
        return this.socketServer.close(function() {
          _this.started = false;
          _this.emit('close');
          if (callback) {
            return callback();
          }
        });
      } else {
        if (callback) {
          return callback(new Error('Already closed'));
        }
      }
    };

    ReplrServer.prototype.open = function(socket, overriddenOptions) {
      var client, clientOptions, exports, key, originalValue, replOptions, value, _i, _len, _ref, _ref1,
        _this = this;
      if (overriddenOptions == null) {
        overriddenOptions = {};
      }
      replOptions = {};
      _ref = this.OPTIONS_REPL_KEYS;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (this.options.hasOwnProperty(key)) {
          replOptions[key] = this.options[key];
        }
      }
      clientOptions = extend(overriddenOptions, this.options);
      client = new ReplrClient(this, socket, clientOptions, replOptions);
      this.clients.push(client);
      socket.on('end', function() {
        return _this.clients.splice(_this.clients.indexOf(client), 1);
      });
      socket.on('error', function(err) {
        if (err && err.code === 'EPIPE') {

        }
      });
      client.repl.context.exported = {};
      _ref1 = client.exports();
      for (key in _ref1) {
        value = _ref1[key];
        client.repl.context.exported[key] = value;
        client.repl.context[key] = value;
      }
      if (this.options.exports && typeof this.options.exports === 'function') {
        exports = this.options.exports(client);
        if (exports && Object.keys(exports).length > 0) {
          for (key in exports) {
            value = exports[key];
            if (typeof value === 'function') {
              originalValue = value;
              value = value.bind(client.repl.context);
              value.unbound = originalValue;
            }
            client.repl.context.exported[key] = value;
            client.repl.context[key] = value;
          }
        }
      }
      client.welcome();
      return client;
    };

    ReplrServer.prototype.forwardToWorker = function(client, worker) {
      var dummy, msg;
      msg = {
        type: ReplrEvents.prototype.WORKER_RECEIVE,
        options: this.options
      };
      dummy = new MemoryStream();
      client.repl.inputStream = dummy;
      client.repl.outputStream = dummy;
      client.repl.rli.input = dummy;
      client.repl.rli.output = dummy;
      return worker.send(msg, client.socket);
    };

    ReplrServer.prototype.describeWorkers = function(callback) {
      var formatTitle, id, worker, workersArray,
        _this = this;
      formatTitle = function(id, worker) {
        return "[" + id + "] id=" + id + ", pid=" + worker.process.pid + "\n";
      };
      if (typeof this.options.describeWorker === 'function') {
        workersArray = (function() {
          var _ref, _results;
          _ref = cluster.workers;
          _results = [];
          for (id in _ref) {
            worker = _ref[id];
            _results.push(worker);
          }
          return _results;
        })();
        return async.map(workersArray, function(worker, cb) {
          return _this.options.describeWorker(worker, function(description) {
            var str;
            str = "" + (formatTitle(worker.id, worker)) + (terminal.lpad(description, 1));
            return cb(null, str);
          });
        }, function(err, results) {
          return callback(results.join("\n"));
        });
      } else {
        return callback(((function() {
          var _ref, _results;
          _ref = cluster.workers;
          _results = [];
          for (id in _ref) {
            worker = _ref[id];
            _results.push(formatTitle(id, worker));
          }
          return _results;
        })()).join("\n"));
      }
    };

    return ReplrServer;

  })(EventEmitter);

  module.exports = ReplrServer;

}).call(this);
